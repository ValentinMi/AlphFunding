Contract Pool(
    creator: Address,
    beneficiary: Address,
    end: U256,
    goal: U256,
    mut totalCollected: U256
) {
    
    mapping[Address, U256] contributions

    event Contribute(contributor: Address, amount: U256, totalCollected: U256)

    enum ErrorCodes {
        CollectIsFinished = 0
        GoalAlreadyReached = 1
        CollectNotFinished = 2
        NotTheBeneficiary = 3
        NoContribution = 4
        NotEnoughFunds = 5
    }

    pub fn getTotalCollected() -> U256 {
        return totalCollected
    }

    pub fn getEnd() -> U256 {
        return end
    }

    pub fn getGoal() -> U256 {
        return goal
    }

    pub fn getBeneficiary() -> Address {
        return beneficiary
    }

    pub fn getCreator() -> Address {
        return creator
    }


    // Allows to contribute to the pool
    @using(preapprovedAssets = true, updateFields = true, checkExternalCaller = false, assetsInContract = true)
    pub fn contribute(amount: U256) -> () {
        let blockTimeStamp = blockTimeStamp!()
        assert!(blockTimeStamp < end, ErrorCodes.CollectIsFinished)
        assert!(amount > 0, ErrorCodes.NotEnoughFunds)

        let caller = callerAddress!()
        let key = caller

        transferTokenToSelf!(caller, ALPH, amount)
        contributions.insert!(caller, key, amount)
        totalCollected = totalCollected + amount
        
        emit Contribute(caller, amount, totalCollected)
    }

    // Allows the beneficiary to withdraw pool's gains
    @using(assetsInContract = true)
    pub fn withdraw() -> () {
        let caller = callerAddress!()
        checkCaller!(beneficiary == caller, ErrorCodes.NotTheBeneficiary)

        let blockTimeStamp = blockTimeStamp!()
        assert!(blockTimeStamp >= end && totalCollected >= goal, ErrorCodes.CollectNotFinished)

        destroySelf!(beneficiary)
    }

    // Allows to refund the contribution
    @using(assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn refund() -> () {
        let blockTimeStamp = blockTimeStamp!()
        assert!(blockTimeStamp < end, ErrorCodes.CollectIsFinished)
        
        assert!(totalCollected < goal, ErrorCodes.GoalAlreadyReached)
        
        let caller = callerAddress!()
        assert!(contributions.contains!(caller), ErrorCodes.NoContribution)

        let contributionAmount = contributions[caller]

        contributions.remove!(caller, caller)
        totalCollected = totalCollected - contributionAmount

        transferTokenFromSelf!(caller, ALPH, contributionAmount)
    }
    
}